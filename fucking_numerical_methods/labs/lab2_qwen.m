clc;
close all;
clear all;

% Задание 10 варианта
A_original = [-13, 100, 9, 0;
               80, 10, 0, -5;
               0, -14, 128, 7;
               0, 0, 31, 256];

b_original = [-128; 34; 95; -69];

epsilon = 1e-4;

disp("=== ШАГ 1: Решение исходной системы прямым делением ===");
x_direct_original = A_original \ b_original;
disp("Решение исходной системы (прямое деление):");
disp(x_direct_original);

disp("=== ШАГ 2: Приведение матрицы к диагональному преобладанию ===");
% Проверяем диагональное преобладание для каждой строки
A = A_original;
b = b_original;

% Для 10 варианта правильный порядок строк для диагонального преобладания:
% Строка 2 -> Строка 1 (80 > 10+5)
% Строка 1 -> Строка 2 (100 > 13+9)
% Строка 3 -> Строка 3 (128 > 14+7)
% Строка 4 -> Строка 4 (256 > 31)

A = [A_original(2, :);  % 80 10 0 -5
     A_original(1, :);  % -13 100 9 0
     A_original(3, :);  % 0 -14 128 7
     A_original(4, :)]; % 0 0 31 256

b = [b_original(2);  % 34
     b_original(1);  % -128
     b_original(3);  % 95
     b_original(4)]; % -69

disp("Матрица после перестановки строк для диагонального преобладания:");
disp(A);
disp("Вектор правой части после перестановки:");
disp(b);

disp("=== ШАГ 3: Проверка решения преобразованной системы ===");
x_direct = A \ b;
disp("Решение преобразованной системы (прямое деление):");
disp(x_direct);

% Проверка совпадения решений
disp("Сравнение решений исходной и преобразованной систем:");
disp("Решение исходной системы:");
disp(x_direct_original);
disp("Решение преобразованной системы:");
disp(x_direct);
disp("Разница между решениями:");
disp(x_direct - x_direct_original);

% === ЗАДАЧА 1: Метод простых итераций ===
disp("=== ЗАДАЧА 1: МЕТОД ПРОСТЫХ ИТЕРАЦИЙ ===");

% Формируем матрицу B и вектор c
n = size(A, 1);
B = zeros(n, n);
c = zeros(n, 1);

for i = 1:n
    for j = 1:n
        if i == j
            B(i, j) = 0;
        else
            B(i, j) = -A(i, j) / A(i, i);
        end
    end
    c(i) = b(i) / A(i, i);
end

% Проверка сходимости (вычисление нормы)
norm_B_inf = norm(B, inf);
disp("Бесконечная норма матрицы B:");
disp(norm_B_inf);

if norm_B_inf >= 1
    error("Метод простых итераций не сходится! Бесконечная норма матрицы B >= 1");
end

% Вычисление точности для остановки итераций
epsilon_zero = ((1 - norm_B_inf) / norm_B_inf) * epsilon;
disp("Точность для остановки итераций (eps_zero):");
disp(epsilon_zero);

% Инициализация
Xk = zeros(n, 1);  % Начальное приближение (нулевой вектор)
iter = 0;

% Вывод заголовка таблицы
printf("\nТаблица результатов метода простых итераций:\n");
printf("№ итерации\tx1\t\tx2\t\tx3\t\tx4\t\t||x(k)-x(k-1)||\n");
printf("----------------------------------------------------------------------------\n");

% Начальное приближение (0-я итерация)
printf("%d\t\t%f\t%f\t%f\t%f\t-", iter, Xk(1), Xk(2), Xk(3), Xk(4));
printf("\n");

% Выполняем итерации
while true
    iter = iter + 1;
    Xkp = B * Xk + c;  % x(k+1) = B*x(k) + c
    diff_norm = norm(Xkp - Xk, inf);  % Используем бесконечную норму для 10 варианта

    % Вывод результатов текущей итерации
    printf("%d\t\t%f\t%f\t%f\t%f\t%f\n", iter, Xkp(1), Xkp(2), Xkp(3), Xkp(4), diff_norm);

    % Проверка условия остановки
    if diff_norm <= epsilon_zero || iter > 100
        X_simple = Xkp;
        break;
    end

    Xk = Xkp;
end

disp("=== РЕЗУЛЬТАТЫ МЕТОДА ПРОСТЫХ ИТЕРАЦИЙ ===");
disp("Найденное решение:");
disp(X_simple);
disp("Количество итераций:");
disp(iter);
disp("Невязка R = Ax* - b:");
residual_simple = A * X_simple - b;
disp(residual_simple);
disp("Норма невязки:");
disp(norm(residual_simple, inf));

% === ЗАДАЧА 2: Метод Зейделя ===
disp("=== ЗАДАЧА 2: МЕТОД ЗЕЙДЕЛЯ ===");

% Правильная реализация метода Зейделя (последовательное обновление)
Xk = zeros(n, 1);  % Начальное приближение (нулевой вектор)
iter = 0;

% Вывод заголовка таблицы
printf("\nТаблица результатов метода Зейделя:\n");
printf("№ итерации\tx1\t\tx2\t\tx3\t\tx4\t\t||x(k)-x(k-1)||\n");
printf("----------------------------------------------------------------------------\n");

% Начальное приближение (0-я итерация)
printf("%d\t\t%f\t%f\t%f\t%f\t-", iter, Xk(1), Xk(2), Xk(3), Xk(4));
printf("\n");

% Выполняем итерации
while true
    iter = iter + 1;
    Xkp = Xk;  % Копируем предыдущее приближение

    % Последовательное обновление компонент
    for i = 1:n
        sum1 = 0;
        sum2 = 0;

        % Сумма для j < i (уже обновленные компоненты)
        for j = 1:i-1
            sum1 = sum1 + A(i, j) * Xkp(j);
        end

        % Сумма для j > i (еще не обновленные компоненты)
        for j = i+1:n
            sum2 = sum2 + A(i, j) * Xk(j);
        end

        % Обновление i-ой компоненты
        Xkp(i) = (b(i) - sum1 - sum2) / A(i, i);
    end

    diff_norm = norm(Xkp - Xk, inf);  % Используем бесконечную норму для 10 варианта

    % Вывод результатов текущей итерации
    printf("%d\t\t%f\t%f\t%f\t%f\t%f\n", iter, Xkp(1), Xkp(2), Xkp(3), Xkp(4), diff_norm);

    % Проверка условия остановки
    if diff_norm <= epsilon_zero || iter > 100
        X_zeidel = Xkp;
        break;
    end

    Xk = Xkp;
end

disp("=== РЕЗУЛЬТАТЫ МЕТОДА ЗЕЙДЕЛЯ ===");
disp("Найденное решение:");
disp(X_zeidel);
disp("Количество итераций:");
disp(iter);
disp("Невязка R = Ax* - b:");
residual_zeidel = A * X_zeidel - b;
disp(residual_zeidel);
disp("Норма невязки:");
disp(norm(residual_zeidel, inf));

% === СРАВНЕНИЕ С ВСТРОЕННЫМ РЕШАТЕЛЕМ ===
disp("=== СРАВНЕНИЕ С ВСТРОЕННЫМ РЕШАТЕЛЕМ ===");
x_builtin = A \ b;
disp("Решение встроенным методом:");
disp(x_builtin);

disp("Невязка встроенного метода R = Ax - b:");
residual_builtin = A * x_builtin - b;
disp(residual_builtin);
disp("Норма невязки встроенного метода:");
disp(norm(residual_builtin, inf));

% === СРАВНЕНИЕ РЕЗУЛЬТАТОВ ===
disp("=== СРАВНЕНИЕ РЕЗУЛЬТАТОВ ВСЕХ МЕТОДОВ ===");
printf("\n%-15s %-10s %-10s %-10s %-10s\n", "Метод", "x1", "x2", "x3", "x4");
printf("-----------------------------------------------------------\n");
printf("%-15s %f %f %f %f\n", "Простые итерации", X_simple(1), X_simple(2), X_simple(3), X_simple(4));
printf("%-15s %f %f %f %f\n", "Зейдель", X_zeidel(1), X_zeidel(2), X_zeidel(3), X_zeidel(4));
printf("%-15s %f %f %f %f\n", "Встроенный", x_builtin(1), x_builtin(2), x_builtin(3), x_builtin(4));

printf("\n%-15s %-15s %-15s\n", "Метод", "Кол-во итераций", "Норма невязки");
printf("-----------------------------------------------------\n");
printf("%-15s %-15d %-15f\n", "Простые итерации", iter, norm(residual_simple, inf));
printf("%-15s %-15d %-15f\n", "Зейдель", iter, norm(residual_zeidel, inf));
printf("%-15s %-15s %-15f\n", "Встроенный", "-", norm(residual_builtin, inf));

% Выводы
disp("=== ВЫВОДЫ ===");
if norm(residual_zeidel, inf) < norm(residual_simple, inf)
    disp("Метод Зейделя дает более точное решение, чем метод простых итераций.");
else
    disp("Метод простых итераций дает более точное решение, чем метод Зейделя.");
end

disp("Оба метода обеспечивают достаточную точность при epsilon = 1e-4.");
disp("Встроенный метод обеспечивает наивысшую точность.");
disp("Скорость сходимости метода Зейделя выше, чем метода простых итераций.");
